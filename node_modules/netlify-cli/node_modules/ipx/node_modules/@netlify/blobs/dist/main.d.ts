import http from 'node:http';

type ConsistencyMode = 'eventual' | 'strong';

declare global {
    var netlifyBlobsContext: unknown;
}

type Metadata = Record<string, unknown>;

type BlobInput = string | ArrayBuffer | Blob;
type Fetcher = typeof globalThis.fetch;
declare enum HTTPMethod {
    DELETE = "delete",
    GET = "get",
    HEAD = "head",
    PUT = "put"
}

interface MakeStoreRequestOptions {
    body?: BlobInput | null;
    consistency?: ConsistencyMode;
    headers?: Record<string, string>;
    key?: string;
    metadata?: Metadata;
    method: HTTPMethod;
    parameters?: Record<string, string>;
    storeName: string;
}
interface ClientOptions {
    apiURL?: string;
    consistency?: ConsistencyMode;
    edgeURL?: string;
    fetch?: Fetcher;
    siteID: string;
    token: string;
    uncachedEdgeURL?: string;
}
declare class Client {
    private apiURL?;
    private consistency;
    private edgeURL?;
    private fetch;
    private siteID;
    private token;
    private uncachedEdgeURL?;
    constructor({ apiURL, consistency, edgeURL, fetch, siteID, token, uncachedEdgeURL }: ClientOptions);
    private getFinalRequest;
    makeRequest({ body, consistency, headers: extraHeaders, key, metadata, method, parameters, storeName, }: MakeStoreRequestOptions): Promise<Response>;
}

interface BaseStoreOptions {
    client: Client;
    consistency?: ConsistencyMode;
}
interface DeployStoreOptions extends BaseStoreOptions {
    deployID: string;
}
interface NamedStoreOptions extends BaseStoreOptions {
    name: string;
}
type StoreOptions = DeployStoreOptions | NamedStoreOptions;
interface GetOptions {
    consistency?: ConsistencyMode;
}
interface GetWithMetadataOptions {
    consistency?: ConsistencyMode;
    etag?: string;
}
interface GetWithMetadataResult {
    etag?: string;
    metadata: Metadata;
}
interface ListResult {
    blobs: ListResultBlob[];
    directories: string[];
}
interface ListResultBlob {
    etag: string;
    key: string;
}
interface ListOptions {
    directories?: boolean;
    paginate?: boolean;
    prefix?: string;
}
interface SetOptions {
    /**
     * Arbitrary metadata object to associate with an entry. Must be seralizable
     * to JSON.
     */
    metadata?: Metadata;
}
type BlobResponseType = 'arrayBuffer' | 'blob' | 'json' | 'stream' | 'text';
declare class Store {
    private client;
    private consistency;
    private name;
    constructor(options: StoreOptions);
    delete(key: string): Promise<void>;
    get(key: string): Promise<string>;
    get(key: string, opts: GetOptions): Promise<string>;
    get(key: string, { type }: GetOptions & {
        type: 'arrayBuffer';
    }): Promise<ArrayBuffer>;
    get(key: string, { type }: GetOptions & {
        type: 'blob';
    }): Promise<Blob>;
    get(key: string, { type }: GetOptions & {
        type: 'json';
    }): Promise<any>;
    get(key: string, { type }: GetOptions & {
        type: 'stream';
    }): Promise<ReadableStream>;
    get(key: string, { type }: GetOptions & {
        type: 'text';
    }): Promise<string>;
    getMetadata(key: string, { consistency }?: {
        consistency?: ConsistencyMode;
    }): Promise<{
        etag: string | undefined;
        metadata: Metadata;
    } | null>;
    getWithMetadata(key: string, options?: GetWithMetadataOptions): Promise<({
        data: string;
    } & GetWithMetadataResult) | null>;
    getWithMetadata(key: string, options: {
        type: 'arrayBuffer';
    } & GetWithMetadataOptions): Promise<{
        data: ArrayBuffer;
    } & GetWithMetadataResult>;
    getWithMetadata(key: string, options: {
        type: 'blob';
    } & GetWithMetadataOptions): Promise<({
        data: Blob;
    } & GetWithMetadataResult) | null>;
    getWithMetadata(key: string, options: {
        type: 'json';
    } & GetWithMetadataOptions): Promise<({
        data: any;
    } & GetWithMetadataResult) | null>;
    getWithMetadata(key: string, options: {
        type: 'stream';
    } & GetWithMetadataOptions): Promise<({
        data: ReadableStream;
    } & GetWithMetadataResult) | null>;
    getWithMetadata(key: string, options: {
        type: 'text';
    } & GetWithMetadataOptions): Promise<({
        data: string;
    } & GetWithMetadataResult) | null>;
    list(options: ListOptions & {
        paginate: true;
    }): AsyncIterable<ListResult>;
    list(options?: ListOptions & {
        paginate?: false;
    }): Promise<ListResult>;
    set(key: string, data: BlobInput, { metadata }?: SetOptions): Promise<void>;
    setJSON(key: string, data: unknown, { metadata }?: SetOptions): Promise<void>;
    private static formatListResultBlob;
    private static validateKey;
    private static validateDeployID;
    private static validateStoreName;
    private getListIterator;
}

interface GetDeployStoreOptions extends Partial<ClientOptions> {
    deployID?: string;
}
/**
 * Gets a reference to a deploy-scoped store.
 */
declare const getDeployStore: (options?: GetDeployStoreOptions) => Store;
interface GetStoreOptions extends Partial<ClientOptions> {
    deployID?: string;
    name?: string;
}
/**
 * Gets a reference to a store.
 *
 * @param input Either a string containing the store name or an options object
 */
declare const getStore: {
    (name: string): Store;
    (options: GetStoreOptions): Store;
};

type Logger = (...message: unknown[]) => void;

declare enum Operation {
    DELETE = "delete",
    GET = "get",
    GET_METADATA = "getMetadata",
    LIST = "list",
    SET = "set"
}
interface BlobsServerOptions {
    /**
     * Whether debug-level information should be logged, such as internal errors
     * or information about incoming requests.
     */
    debug?: boolean;
    /**
     * Base directory to read and write files from.
     */
    directory: string;
    /**
     * Function to log messages. Defaults to `console.log`.
     */
    logger?: Logger;
    /**
     * Callback function to be called on every request.
     */
    onRequest?: (parameters: {
        type: Operation;
    }) => void;
    /**
     * Port to run the server on. Defaults to a random port.
     */
    port?: number;
    /**
     * Static authentication token that should be present in all requests. If not
     * supplied, no authentication check is performed.
     */
    token?: string;
}
declare class BlobsServer {
    private address;
    private debug;
    private directory;
    private logger;
    private onRequest;
    private port;
    private server?;
    private token?;
    private tokenHash;
    constructor({ debug, directory, logger, onRequest, port, token }: BlobsServerOptions);
    logDebug(...message: unknown[]): void;
    delete(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    get(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    head(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    list(options: {
        dataPath: string;
        metadataPath: string;
        rootPath: string;
        req: http.IncomingMessage;
        res: http.ServerResponse;
        url: URL;
    }): Promise<void>;
    put(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    /**
     * Parses the URL and returns the filesystem paths where entries and metadata
     * should be stored.
     */
    getLocalPaths(url?: URL): {
        dataPath?: undefined;
        key?: undefined;
        metadataPath?: undefined;
        rootPath?: undefined;
    } | {
        dataPath: string;
        key: string;
        metadataPath: string;
        rootPath: string;
    };
    handleRequest(req: http.IncomingMessage, res: http.ServerResponse): void | Promise<void>;
    /**
     * Tries to parse a URL as being an API request and returns the different
     * components, such as the store name, site ID, key, and signed URL.
     */
    parseAPIRequest(req: http.IncomingMessage): {
        key: string | undefined;
        siteID: string;
        storeName: string;
        url: URL;
    } | null;
    sendResponse(req: http.IncomingMessage, res: http.ServerResponse, status: number, body?: string): void;
    start(): Promise<{
        address: string;
        family: string;
        port: number;
    }>;
    stop(): Promise<void>;
    validateAccess(req: http.IncomingMessage): boolean;
    /**
     * Traverses a path and collects both blobs and directories into a `result`
     * object, taking into account the `directories` and `prefix` parameters.
     */
    private static walk;
}

export { BlobResponseType, BlobsServer, GetWithMetadataOptions, GetWithMetadataResult, ListOptions, ListResultBlob, SetOptions, Store, StoreOptions, getDeployStore, getStore };
