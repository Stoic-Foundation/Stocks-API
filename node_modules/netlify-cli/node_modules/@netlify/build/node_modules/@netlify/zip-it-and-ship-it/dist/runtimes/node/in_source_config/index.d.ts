import type { ArgumentPlaceholder, Expression, SpreadElement, JSXNamespacedName } from '@babel/types';
import { InvocationMode } from '../../../function.js';
import { Logger } from '../../../utils/logger.js';
import { Route } from '../../../utils/routes.js';
import type { ModuleFormat } from '../utils/module_format.js';
export declare const IN_SOURCE_CONFIG_MODULE = "@netlify/functions";
export type ISCValues = {
    routes?: Route[];
    schedule?: string;
    methods?: string[];
};
export interface StaticAnalysisResult extends ISCValues {
    inputModuleFormat?: ModuleFormat;
    invocationMode?: InvocationMode;
    runtimeAPIVersion?: number;
}
interface FindISCDeclarationsOptions {
    functionName: string;
    logger: Logger;
}
/**
 * Loads a file at a given path, parses it into an AST, and returns a series of
 * data points, such as in-source configuration properties and other metadata.
 */
export declare const parseFile: (sourcePath: string, { functionName, logger }: FindISCDeclarationsOptions) => Promise<StaticAnalysisResult>;
/**
 * Takes a JS/TS source as a string, parses it into an AST, and returns a
 * series of data points, such as in-source configuration properties and
 * other metadata.
 */
export declare const parseSource: (source: string, { functionName, logger }: FindISCDeclarationsOptions) => StaticAnalysisResult;
export type ISCHandlerArg = ArgumentPlaceholder | Expression | SpreadElement | JSXNamespacedName;
export type ISCExportWithCallExpression = {
    type: 'call-expression';
    args: ISCHandlerArg[];
    local: string;
};
export type ISCExportWithObject = {
    type: 'object-expression';
    object: Record<string, unknown>;
};
export type ISCExportOther = {
    type: 'other';
};
export type ISCDefaultExport = {
    type: 'default';
};
export type ISCExport = ISCExportWithCallExpression | ISCExportWithObject | ISCExportOther | ISCDefaultExport;
export {};
