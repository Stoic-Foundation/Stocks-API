import { promises as fs } from 'fs';
import { join, resolve } from 'path';
import { stderr, stdout } from 'process';
import { fileURLToPath, pathToFileURL } from 'url';
import { execa } from 'execa';
import tmp from 'tmp-promise';
import { getLogger } from '../node/logger.js';
const testLogger = getLogger(() => {
    // no-op
});
const url = new URL(import.meta.url);
const dirname = fileURLToPath(url);
const fixturesDir = resolve(dirname, '..', 'fixtures');
const useFixture = async (fixtureName) => {
    const tmpDir = await tmp.dir({ unsafeCleanup: true });
    const fixtureDir = resolve(fixturesDir, fixtureName);
    const distPath = join(tmpDir.path, '.netlify', 'edge-functions-dist');
    return {
        basePath: fixtureDir,
        cleanup: tmpDir.cleanup,
        distPath,
    };
};
const inspectFunction = (path) => `
  import { functions } from "${pathToFileURL(path)}.js";

  const responses = {};

  for (const functionName in functions) {
    const req = new Request("https://test.netlify");
    const res = await functions[functionName](req);

    responses[functionName] = await res.text();
  }
  
  console.log(JSON.stringify(responses));
`;
const getRouteMatcher = (manifest) => (candidate) => manifest.routes.find((route) => {
    var _a, _b;
    const regex = new RegExp(route.pattern);
    if (!regex.test(candidate)) {
        return false;
    }
    if (route.excluded_patterns.some((pattern) => new RegExp(pattern).test(candidate))) {
        return false;
    }
    const excludedPatterns = (_b = (_a = manifest.function_config[route.function]) === null || _a === void 0 ? void 0 : _a.excluded_patterns) !== null && _b !== void 0 ? _b : [];
    const isExcluded = excludedPatterns.some((pattern) => new RegExp(pattern).test(candidate));
    return !isExcluded;
});
const runESZIP = async (eszipPath, vendorDirectory) => {
    var _a, _b, _c;
    const tmpDir = await tmp.dir({ unsafeCleanup: true });
    // Extract ESZIP into temporary directory.
    const extractCommand = execa('deno', [
        'run',
        '--allow-all',
        'https://deno.land/x/eszip@v0.55.2/eszip.ts',
        'x',
        eszipPath,
        tmpDir.path,
    ]);
    (_a = extractCommand.stderr) === null || _a === void 0 ? void 0 : _a.pipe(stderr);
    (_b = extractCommand.stdout) === null || _b === void 0 ? void 0 : _b.pipe(stdout);
    await extractCommand;
    const virtualRootPath = join(tmpDir.path, 'source', 'root');
    const stage2Path = join(virtualRootPath, '..', 'bootstrap-stage2');
    const importMapPath = join(virtualRootPath, '..', 'import-map');
    for (const path of [importMapPath, stage2Path]) {
        const file = await fs.readFile(path, 'utf8');
        let normalizedFile = file.replace(/file:\/{3}root/g, pathToFileURL(virtualRootPath).toString());
        if (vendorDirectory !== undefined) {
            normalizedFile = normalizedFile.replace(/file:\/{3}vendor/g, pathToFileURL(vendorDirectory).toString());
        }
        await fs.writeFile(path, normalizedFile);
    }
    await fs.rename(stage2Path, `${stage2Path}.js`);
    // Run function that imports the extracted stage 2 and invokes each function.
    const evalCommand = execa('deno', ['eval', '--no-check', '--import-map', importMapPath, inspectFunction(stage2Path)]);
    (_c = evalCommand.stderr) === null || _c === void 0 ? void 0 : _c.pipe(stderr);
    const result = await evalCommand;
    await tmpDir.cleanup();
    return JSON.parse(result.stdout);
};
export { fixturesDir, getRouteMatcher, testLogger, runESZIP, useFixture };
