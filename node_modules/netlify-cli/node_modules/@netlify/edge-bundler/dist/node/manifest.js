import { promises as fs } from 'fs';
import { join } from 'path';
import { wrapBundleError } from './bundle_error.js';
import { normalizePattern } from './declaration.js';
import { getPackageVersion } from './package_json.js';
import { nonNullable } from './utils/non_nullable.js';
import { ExtendedURLPattern } from './utils/urlpattern.js';
const removeEmptyConfigValues = (functionConfig) => Object.entries(functionConfig).reduce((acc, [key, value]) => {
    if (value && !(Array.isArray(value) && value.length === 0)) {
        return { ...acc, [key]: value };
    }
    return acc;
}, {});
// JavaScript regular expressions are converted to strings with leading and
// trailing slashes, so any slashes inside the expression itself are escaped
// as `//`. This function deserializes that back into a single slash, which
// is the format we want to use in the manifest.
const serializePattern = (pattern) => pattern.replace(/\\\//g, '/');
const sanitizeEdgeFunctionConfig = (config) => {
    const newConfig = {};
    for (const [name, functionConfig] of Object.entries(config)) {
        const newFunctionConfig = removeEmptyConfigValues(functionConfig);
        if (Object.keys(newFunctionConfig).length !== 0) {
            newConfig[name] = newFunctionConfig;
        }
    }
    return newConfig;
};
const addExcludedPatterns = (name, manifestFunctionConfig, excludedPath) => {
    if (excludedPath) {
        const paths = Array.isArray(excludedPath) ? excludedPath : [excludedPath];
        const excludedPatterns = paths.map(pathToRegularExpression).filter(nonNullable).map(serializePattern);
        manifestFunctionConfig[name].excluded_patterns.push(...excludedPatterns);
    }
};
/**
 * Normalizes method names into arrays of uppercase strings.
 * (e.g. "get" becomes ["GET"])
 */
const normalizeMethods = (method, name) => {
    const methods = Array.isArray(method) ? method : [method];
    return methods.map((method) => {
        if (typeof method !== 'string') {
            throw new TypeError(`Could not parse method declaration of function '${name}'. Expecting HTTP Method, got ${method}`);
        }
        return method.toUpperCase();
    });
};
const generateManifest = ({ bundles = [], declarations = [], functions, userFunctionConfig = {}, internalFunctionConfig = {}, importMap, layers = [], }) => {
    const preCacheRoutes = [];
    const postCacheRoutes = [];
    const manifestFunctionConfig = Object.fromEntries(functions.map(({ name }) => [name, { excluded_patterns: [] }]));
    const routedFunctions = new Set();
    const declarationsWithoutFunction = new Set();
    for (const [name, { excludedPath, onError }] of Object.entries(userFunctionConfig)) {
        // If the config block is for a function that is not defined, discard it.
        if (manifestFunctionConfig[name] === undefined) {
            continue;
        }
        addExcludedPatterns(name, manifestFunctionConfig, excludedPath);
        manifestFunctionConfig[name] = { ...manifestFunctionConfig[name], on_error: onError };
    }
    for (const [name, { excludedPath, path, onError, ...rest }] of Object.entries(internalFunctionConfig)) {
        // If the config block is for a function that is not defined, discard it.
        if (manifestFunctionConfig[name] === undefined) {
            continue;
        }
        addExcludedPatterns(name, manifestFunctionConfig, excludedPath);
        manifestFunctionConfig[name] = { ...manifestFunctionConfig[name], on_error: onError, ...rest };
    }
    declarations.forEach((declaration) => {
        const func = functions.find(({ name }) => declaration.function === name);
        if (func === undefined) {
            declarationsWithoutFunction.add(declaration.function);
            return;
        }
        const pattern = getRegularExpression(declaration);
        // If there is no `pattern`, the declaration will never be triggered, so we
        // can discard it.
        if (!pattern) {
            return;
        }
        routedFunctions.add(declaration.function);
        const excludedPattern = getExcludedRegularExpressions(declaration);
        const route = {
            function: func.name,
            pattern: serializePattern(pattern),
            excluded_patterns: excludedPattern.map(serializePattern),
        };
        if ('method' in declaration) {
            route.methods = normalizeMethods(declaration.method, func.name);
        }
        if ('path' in declaration) {
            route.path = declaration.path;
        }
        if (declaration.cache === "manual" /* Cache.Manual */) {
            postCacheRoutes.push(route);
        }
        else {
            preCacheRoutes.push(route);
        }
    });
    const manifestBundles = bundles.map(({ extension, format, hash }) => ({
        asset: hash + extension,
        format,
    }));
    const manifest = {
        bundles: manifestBundles,
        routes: preCacheRoutes.filter(nonNullable),
        post_cache_routes: postCacheRoutes.filter(nonNullable),
        bundler_version: getPackageVersion(),
        layers,
        import_map: importMap,
        function_config: sanitizeEdgeFunctionConfig(manifestFunctionConfig),
    };
    const unroutedFunctions = functions.filter(({ name }) => !routedFunctions.has(name)).map(({ name }) => name);
    return { declarationsWithoutFunction: [...declarationsWithoutFunction], manifest, unroutedFunctions };
};
const pathToRegularExpression = (path) => {
    if (!path) {
        return null;
    }
    try {
        const pattern = new ExtendedURLPattern({ pathname: path });
        // Removing the `^` and `$` delimiters because we'll need to modify what's
        // between them.
        const source = pattern.regexp.pathname.source.slice(1, -1);
        // Wrapping the expression source with `^` and `$`. Also, adding an optional
        // trailing slash, so that a declaration of `path: "/foo"` matches requests
        // for both `/foo` and `/foo/`.
        const normalizedSource = `^${source}\\/?$`;
        return normalizedSource;
    }
    catch (error) {
        throw wrapBundleError(error);
    }
};
const getRegularExpression = (declaration) => {
    if ('pattern' in declaration) {
        try {
            return normalizePattern(declaration.pattern);
        }
        catch (error) {
            throw wrapBundleError(new Error(`Could not parse path declaration of function '${declaration.function}': ${error.message}`));
        }
    }
    return pathToRegularExpression(declaration.path);
};
const getExcludedRegularExpressions = (declaration) => {
    if ('excludedPattern' in declaration && declaration.excludedPattern) {
        const excludedPatterns = Array.isArray(declaration.excludedPattern)
            ? declaration.excludedPattern
            : [declaration.excludedPattern];
        return excludedPatterns.map((excludedPattern) => {
            try {
                return normalizePattern(excludedPattern);
            }
            catch (error) {
                throw wrapBundleError(new Error(`Could not parse path declaration of function '${declaration.function}': ${error.message}`));
            }
        });
    }
    if ('path' in declaration && declaration.excludedPath) {
        const paths = Array.isArray(declaration.excludedPath) ? declaration.excludedPath : [declaration.excludedPath];
        return paths.map(pathToRegularExpression).filter(nonNullable);
    }
    return [];
};
const writeManifest = async ({ distDirectory, ...rest }) => {
    const { manifest } = generateManifest(rest);
    const manifestPath = join(distDirectory, 'manifest.json');
    await fs.writeFile(manifestPath, JSON.stringify(manifest));
    return manifest;
};
export { generateManifest, writeManifest };
