"use strict";
// Co-authored by @gadicc, @PythonCreator27 and @huned.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._chart = void 0;
const queryOptionsDefaults = {
    useYfid: true,
    interval: "1d",
    includePrePost: true,
    events: "div|split|earn",
    lang: "en-US",
    return: "array",
};
/* --- array input, typed output, honor "return" param --- */
// TODO: make this a deprecration passthrough
exports._chart = chart;
function chart(symbol, queryOptionsOverrides, moduleOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        const returnAs = (queryOptionsOverrides === null || queryOptionsOverrides === void 0 ? void 0 : queryOptionsOverrides.return) || "array";
        const result = (yield this._moduleExec({
            moduleName: "chart",
            query: {
                assertSymbol: symbol,
                url: "https://${YF_QUERY_HOST}/v8/finance/chart/" + symbol,
                schemaKey: "#/definitions/ChartOptions",
                defaults: queryOptionsDefaults,
                overrides: queryOptionsOverrides,
                transformWith(queryOptions) {
                    if (!queryOptions.period2)
                        queryOptions.period2 = new Date();
                    const dates = ["period1", "period2"];
                    for (const fieldName of dates) {
                        const value = queryOptions[fieldName];
                        if (value instanceof Date)
                            queryOptions[fieldName] = Math.floor(value.getTime() / 1000);
                        else
                            typeof value === "string";
                        queryOptions[fieldName] = Math.floor(new Date(value).getTime() / 1000);
                    }
                    if (queryOptions.period1 === queryOptions.period2) {
                        throw new Error("yahooFinance.chart() options `period1` and `period2` " +
                            "cannot share the same value.");
                    }
                    // Don't pass this on to Yahoo
                    delete queryOptions.return;
                    return queryOptions;
                },
            },
            result: {
                schemaKey: "#/definitions/ChartResultObject",
                transformWith(result) {
                    if (!result.chart)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    const chart = result.chart.result[0];
                    // If there are no quotes, chart.timestamp will be empty, but Yahoo also
                    // gives us chart.indicators.quotes = [{}].  Let's clean that up and
                    // deliver an empty array rather than an invalid ChartIndicatorQuote/
                    if (!chart.timestamp) {
                        if (chart.indicators.quote.length !== 1)
                            throw new Error("No timestamp with quotes.length !== 1, please report with your query");
                        if (Object.keys(chart.indicators.quote[0]).length !== 0)
                            // i.e. {}
                            throw new Error("No timestamp with unexpected quote, please report with your query" +
                                JSON.stringify(chart.indicators.quote[0]));
                        chart.indicators.quote.pop();
                    }
                    return chart;
                },
            },
            moduleOptions,
        }));
        if (returnAs === "object") {
            return result;
        }
        else if (returnAs === "array") {
            const timestamp = result.timestamp;
            /*
            seems as though yahoo inserts extra quotes at the event times, so no need.
            if (result.events) {
              for (let event of ["dividends", "splits"]) {
                // @ts-ignore
                if (result.events[event])
                  // @ts-ignore
                  timestamp = timestamp.filter((ts) => !result.events[event][ts]);
              }
            }
            */
            // istanbul ignore next
            if (timestamp &&
                ((_a = result === null || result === void 0 ? void 0 : result.indicators) === null || _a === void 0 ? void 0 : _a.quote) &&
                result.indicators.quote[0].high.length !== timestamp.length) {
                console.log({
                    origTimestampSize: result.timestamp && result.timestamp.length,
                    filteredSize: timestamp.length,
                    quoteSize: result.indicators.quote[0].high.length,
                });
                throw new Error("Timestamp count mismatch, please report this with the query you used");
            }
            const result2 = {
                meta: result.meta,
                quotes: timestamp ? new Array(timestamp.length) : [],
            };
            const adjclose = (_c = (_b = result === null || result === void 0 ? void 0 : result.indicators) === null || _b === void 0 ? void 0 : _b.adjclose) === null || _c === void 0 ? void 0 : _c[0].adjclose;
            if (timestamp)
                for (let i = 0; i < timestamp.length; i++) {
                    result2.quotes[i] = {
                        date: new Date(timestamp[i] * 1000),
                        high: result.indicators.quote[0].high[i],
                        volume: result.indicators.quote[0].volume[i],
                        open: result.indicators.quote[0].open[i],
                        low: result.indicators.quote[0].low[i],
                        close: result.indicators.quote[0].close[i],
                    };
                    if (adjclose)
                        result2.quotes[i].adjclose = adjclose[i];
                }
            if (result.events) {
                result2.events = {};
                for (const event of ["dividends", "splits"]) {
                    if (result.events[event])
                        result2.events[event] = Object.values(result.events[event]);
                }
            }
            return result2;
        }
        // TypeScript runtime validation ensures no other values for
        // "returnAs" are possible.
    });
}
exports.default = chart;
