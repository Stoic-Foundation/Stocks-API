import { writeFile } from "fs";
import { createProgram, createParser, SchemaGenerator, createFormatter, } from "ts-json-schema-generator";
// @ts-expect-error: no types
import schemaWalker from "oas-schema-walker";
import walkerCallback from "./schema/postWalker.js";
import yfNumberTypeFormatter from "./schema/TypeFormatter/yfNumberTypeFormatter.js";
import yfReferenceTypeFormatter from "./schema/TypeFormatter/yfReferenceTypeFormatter.js";
import yfFunctionIgnorer from "./schema/TypeFormatter/yfFunctionIgnorer.js";
//const OUTPUT_PATH = "schema.json";
const OUTPUT_PATH = process.stdout;
const config = {
    path: "src/{modules/**/!(*spec.ts),lib/options.ts}",
    tsconfig: "tsconfig.json",
    type: "*",
};
const formatter = createFormatter(config, (chainTypeFormatter, circularReferenceTypeFormatter) => {
    var _a;
    chainTypeFormatter
        .addTypeFormatter(new yfReferenceTypeFormatter(circularReferenceTypeFormatter, (_a = config.encodeRefs) !== null && _a !== void 0 ? _a : true))
        .addTypeFormatter(new yfNumberTypeFormatter())
        .addTypeFormatter(new yfFunctionIgnorer());
});
const program = createProgram(config);
const parser = createParser(program, config);
const generator = new SchemaGenerator(program, parser, formatter, config);
const _schema = generator.createSchema(config.type);
const schema = {
    $schema: _schema.$schema,
    $comment: "DO NOT EDIT THIS FILE.  It is generated automatically " +
        "from typescript interfaces in the project.  To update, run " +
        "`yarn schema`.",
    ..._schema,
};
// @ts-expect-error: no types
for (const key of Object.keys(schema.definitions)) {
    // @ts-expect-error: no types
    schemaWalker.walkSchema(schema.definitions[key], {}, {}, walkerCallback);
}
const schemaString = JSON.stringify(schema, null, 2);
function throwErr(err) {
    if (err)
        throw err;
}
if (OUTPUT_PATH === process.stdout) {
    process.stdout.write(schemaString, throwErr);
}
else if (typeof OUTPUT_PATH === "string") {
    writeFile(OUTPUT_PATH, schemaString, throwErr);
}
else {
    throw new Error("Unsupported output path");
}
